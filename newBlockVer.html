<html>
<head>
  <title>New Block Version Submission</title>
  <style type="text/css">
    div {
      margin: 2px;
      padding: 4px;
      vertical-align: top;
    }

    .submitButton { display: block; padding: 4px; background: #222; color: #DDD; font-size: 300%; text-align: center; }

    .artist { background: #FFA; }
    .blockList { background: #CCC; }

    #blockDisplay {
      background: #a7cfdf; /* Old browsers */
      background: -moz-linear-gradient(top,  #a7cfdf 0%, #23538a 100%); /* FF3.6+ */
      background: -webkit-gradient(linear, left top, left bottom, color-stop(0%,#a7cfdf), color-stop(100%,#23538a)); /* Chrome,Safari4+ */
      background: -webkit-linear-gradient(top,  #a7cfdf 0%,#23538a 100%); /* Chrome10+,Safari5.1+ */
      background: -o-linear-gradient(top,  #a7cfdf 0%,#23538a 100%); /* Opera 11.10+ */
      background: -ms-linear-gradient(top,  #a7cfdf 0%,#23538a 100%); /* IE10+ */
      background: linear-gradient(to bottom,  #a7cfdf 0%,#23538a 100%); /* W3C */
      filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#a7cfdf', endColorstr='#23538a',GradientType=0 ); /* IE6-9 */

      display: inline-block;
      text-align: center;
      position: relative;
      width: 260px;
      height: 260px;
    }

    .layer {
      position: absolute;
      display: block;
      padding: 4px;
      top: 0px;
      left: 0px;
    }

    .layer:nth-child(1) { left: 21px; top: 21px; }
    .layer:nth-child(2) { left: 18px; top: 18px; }
    .layer:nth-child(3) { left: 15px; top: 15px; }
    .layer:nth-child(4) { left: 12px; top: 12px; }
    .layer:nth-child(5) { left:  9px; top:  9px; }
    .layer:nth-child(6) { left:  6px; top:  6px; }
    .layer:nth-child(7) { left:  3px; top:  3px; }
    .layer:nth-child(8) { left:  0px; top:  0px; }

    .hidden { display: none; }

    #palDisplay
    {
      background: #a7cfdf; /* Old browsers */
      background: -moz-linear-gradient(top,  #a7cfdf 0%, #23538a 100%); /* FF3.6+ */
      background: -webkit-gradient(linear, left top, left bottom, color-stop(0%,#a7cfdf), color-stop(100%,#23538a)); /* Chrome,Safari4+ */
      background: -webkit-linear-gradient(top,  #a7cfdf 0%,#23538a 100%); /* Chrome10+,Safari5.1+ */
      background: -o-linear-gradient(top,  #a7cfdf 0%,#23538a 100%); /* Opera 11.10+ */
      background: -ms-linear-gradient(top,  #a7cfdf 0%,#23538a 100%); /* IE10+ */
      background: linear-gradient(to bottom,  #a7cfdf 0%,#23538a 100%); /* W3C */
      filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#a7cfdf', endColorstr='#23538a',GradientType=0 ); /* IE6-9 */

      display: inline-block;
      width: 340px;
      text-align: center;
    }

    .block {
      position: relative;
      display: inline-block;
      width: 20px;
      height: 20px;
      margin: 2px;
      border: 1px solid #000;
    }

    .blkLink {
      box-shadow: 1px 1px rgba(0,0,0,0.6);
    }      

    .blkSmooth {
      border-radius: 5px;
    }

    .blkHoverData {
      display: none;
      position: absolute;
      right: 10px;
      bottom: 10px;
      background: #CCC;
      box-shadow: 4px 4px 8px rgba(0, 0, 0, 0.3);
      border: 1px solid black;
      padding: 4px;
     }

    .blkLink:hover > .blkHoverData  { display: block; }

    .data {
      white-space: pre-wrap; 
      font-family: monospace; 
    }

    #blockRaw { 
      background: #FCC; 
      width: 240px; 
      display:block;
    }

    #palRaw {
      background: #CFC; 
      width: 200px; 
      display:block;
    }

    .artistID {
      display: block;
      font-variant: small-caps;
      font-size: 150%;
      background: #DDD;
      padding: 2px 2px 2px 6px;
    }

    .blockID {
      display: block;
      font-variant: small-caps;
      font-size: 120%;
      text-align: right;
      color: #EEE;
      background: #111;
      padding: 2px 6px 2px 2px;
    }

    .bitsPerBlock {
      display: block;
    }

    .pal {
      margin: 2px 0px 2px 0px;
      padding: 0px;
      border: 2px solid;
      box-shadow: 2px 2px 4px rgba(0,0,0,0.6);
    }

    .pal h3 {
      margin: 0px 0px 4px 0px;
      padding: 4px;
      border-bottom: dashed 1px rgba(0,0,0,0.5);
    }

    .bitsUsed {
      display: block;
      text-align: right;
    }

    .blot {
      display: inline-block;
      width: 28px;
      height: 28px;
      margin: 4px;
      border: 2px dotted rgba(255,255,255,0.5);
      box-shadow: 2px 2px 2px rgba(0,0,0,0.4);
      border-radius: 16px;
    }

    .method {
      display: block;
      padding: 2px;
      text-align: center;
    }

  </style>
  <script type="text/javascript">

//====================================================================================================
//                    _   _      _                   _____                 _   _                 
//                   | | | | ___| |_ __   ___ _ __  |  ___|   _ _ __   ___| |_(_) ___  _ __  ___ 
//                   | |_| |/ _ \ | '_ \ / _ \ '__| | |_ | | | | '_ \ / __| __| |/ _ \| '_ \/ __|
//                   |  _  |  __/ | |_) |  __/ |    |  _|| |_| | | | | (__| |_| | (_) | | | \__ \
//                   |_| |_|\___|_| .__/ \___|_|    |_|   \__,_|_| |_|\___|\__|_|\___/|_| |_|___/
//                                |_|                                                            
//=====================================================================================================

function $(id) {
  return document.getElementById(id);
}
function rgb(x) {
  return 'rgb(' + Math.floor(x[0] * 255) + ',' + Math.floor(x[1] * 255) + ',' + Math.floor(x[2] * 255) + ')'
}
function rgba(x) {
  return 'rgba(' + Math.floor(x[0] * 255) + ',' + Math.floor(x[1] * 255) + ',' + Math.floor(x[2] * 255) + ',' + x[3] + ')'
}
function toCssCol(x) {
  return (x.length < 4) ? rgb(x) : rgba(x);
}

function argToParams(args) {
  return '?' + JSON.stringify(args).replace(new RegExp('[{}"]', 'g'), '').replace(new RegExp(':', 'g'), '=').replace(new RegExp(',', 'g'), '&');
}
function aHex(x, i) 
{
  var h = x.toString(16);
  while (h.length < i) {
    h = '0' + h;
  }
  return h.toUpperCase();
}

function BitsToBig(x, num) 
{
  var c = 0;
  var s = [];
  
  for (var i = 0; i < x.length; ++i) 
  {
    if (x[i] >= num) 
    {
      s = s.concat(c);
      c = 0;
    } 
    else 
    {
      c = c * num + x[i];
    }
  }
  
  if (c > 0)
    s = s.concat(c);
  else if (s.length == 0)
    s = [0];
  
  return s;
}

function MakeBit(x, num, padSize) 
{
  var y = []
  
  if (x == 0)
    y = [0];
  
  while (x > 0) 
  {
    var r = x % num;
    y = y.concat(r);
    x = Math.floor(x / num);
  }
  
  if (padSize) 
  {
    while (y.length < padSize) 
    {
      y = y.concat(0);
    }
  }
  
  y = y.reverse();
  return y;
}

function BigToBits(x, num) 
{
  var y = [];
  for (var i = 0; i < x.length; ++i) 
  {
    if (i != 0)
      y = y.concat(num);
    
    y = y.concat(MakeBit(x[i], num));
  }
  
  return y;
}

function StepDown(numSteps, mod) 
{
  var sDiff = Math.ceil(100 / (numSteps - 1));
  
  var i = 0;
  steps = [100];
  while (steps[steps.length - 1] > sDiff) 
  {
    var x = steps[steps.length - 1] - sDiff;
    if (mod && ((i % mod) == 0))
      x += Math.floor(sDiff / 2);
    
    steps = steps.concat(x);
    ++i;
  }
  
  steps = steps.concat(0);
  
  if (mod == undefined)
    mod = 1;
  
  if (steps.length != numSteps) 
  {
    if (mod < numSteps)
      return StepDown(numSteps, mod + 1)
    else
      throw 'Cant Handle Steps';
  }
  
  return steps;
}

//----------------------------------------------------------------------------------
//                                     __     __         _ _     _           
//                                     \ \   / /_ _ _ __(_) |__ | | ___  ___ 
//                                      \ \ / / _` | '__| | '_ \| |/ _ \/ __|
//                                       \ V / (_| | |  | | |_) | |  __/\__ \
//                                        \_/ \__,_|_|  |_|_.__/|_|\___||___/
//                                                                           
//----------------------------------------------------------------------------------

var rawResponse;
var lastResponse;
var shadingMethods = {0: 'multiply',1: 'blend'};

var currBlock = 
{
  'artistID': 0,
  'blockID': 0,
  'size': 8,
  'palColour': {'bits': 3,'colours': [[0, 0, 0], [1, 1, 1], [1, 0, 0], [0, 1, 0], [0, 0, 1], [1, 1, 0], [1, 0, 1], [0, 1, 1]]},
  'palAlpha': {'bits': 1,'scale': [100, 50]},
  'palShade': {'bits': 2,'colour': [0, 0, 0],'method': 0,'scale': [0, 33, 66, 100]},
  'palSmooth': {'bits': 0},
  
  'blkBits': [
    {'empty': 0,'link': 0,'colour': 3,'alpha': 0,'shade': 0,'smooth': 0}, 
    {'empty': 1,'link': [1, 2],'colour': 3,}
  ]
};

// Temp Populate Function
currBlock.blkBits = []
for (var i = 0; i < (currBlock.size * currBlock.size * currBlock.size); ++i) 
{
  var newBlock = {};
  
  newBlock.empty = Math.floor(Math.random() * 2);
  newBlock.link = undefined;
  newBlock.colour = Math.floor(Math.random() * (Math.pow(2, currBlock.palColour.bits)));
  newBlock.alpha = Math.floor(Math.random() * (Math.pow(2, currBlock.palAlpha.bits)));
  newBlock.shade = Math.floor(Math.random() * (Math.pow(2, currBlock.palShade.bits)));
  newBlock.smooth = undefined;
  
  if (Math.random() < 0.25) 
  {
    newBlock.link = [Math.floor(Math.random() * 10000000), Math.floor(Math.random() * 50000)];
  } 
  else 
  {
    newBlock.link = undefined;
  }
  
  currBlock.blkBits = currBlock.blkBits.concat(newBlock);
}


//----------------------------------------------------------------------------------
//                                         _                _      
//                                        | |    ___   __ _(_) ___ 
//                                        | |   / _ \ / _` | |/ __|
//                                        | |__| (_) | (_| | | (__ 
//                                        |_____\___/ \__, |_|\___|
//                                                    |___/        
//----------------------------------------------------------------------------------
function NumBitsPerBlockBit(block) 
{
  var x = 2;
  if (block.palColour && block.palColour.bits)
    x += block.palColour.bits;
  
  if (block.palAlpha && block.palAlpha.bits)
    x += block.palAlpha.bits;
  
  if (block.palShade && block.palShade.bits)
    x += block.palShade.bits;
  
  if (block.palSmooth && block.palSmooth.bits)
    x += block.palSmooth.bits;
  
  return x;
}

function BlockBitToBytes(block, bit) 
{
  var x = (bit.empty) ? 1 : 0 + (bit.link) ? 2 : 0;
  var c = 2;
  
  if (block.palColour && block.palColour.bits) 
  {
    var limit = Math.pow(2, block.palColour.bits);
    if (bit.colour >= limit) 
    {
      bit.colour = bit.colour % limit
      console.warn('Colour out of Range');
    }
    
    x += bit.colour << c;
    c += block.palColour.bits;
  }
  
  if (block.palAlpha && block.palAlpha.bits) 
  {
    var limit = Math.pow(2, block.palAlpha.bits);
    if (bit.alpha >= limit) 
    {
      bit.alpha = bit.alpha % limit
      console.warn('Alpha out of Range');
    }
    
    x += bit.alpha << c;
    c += block.palAlpha.bits;
  }
  
  if (block.palShade && block.palShade.bits) 
  {
    var limit = Math.pow(2, block.palShade.bits);
    if (bit.shade >= limit) 
    {
      bit.shade = bit.shade % limit
      console.warn('Shade out of Range');
    }
    
    x += bit.shade << c;
    c += block.palShade.bits;
  }
  
  if (block.palSmooth && block.palSmooth.bits) 
  {
    var limit = Math.pow(2, block.palSmooth.bits);
    if (bit.shade >= limit) 
    {
      bit.shade = bit.shade % limit
      console.warn('Smooth out of Range');
    }
    
    x += bit.smooth << c;
    c += block.palSmooth.bits;
  }
  
  if (c >= 256) 
  {
    console.warn('Out of 8bit Range: ' + x);
  }
  
  return x;
}

// Artist        Block          Size  Colour               Alpha      Shade                   Smooth
// [AA AA AA AA] [BB BB BB BB]  ZZ    XX[[FF FF FF] x 32]  XX[FFx16]  XX[ MM FF FF FF FFx16]  XX
function PalToBytes(block) 
{
  var palBytes = [];
  
  palBytes = palBytes.concat(MakeBit(block.artistID, 255, 4));
  palBytes = palBytes.concat(MakeBit(block.blockID, 255, 4));
  palBytes = palBytes.concat(block.size);

  // Process Colour Pallete
  if (block.palColour) 
  {
    var bits = (block.palColour.bits) ? (block.palColour.bits) : 0;
    var reqLen = Math.pow(2, bits);
    
    if (block.palColour.colours.length > reqLen)
      block.palColour.colours = block.palColour.colours.slice(0, reqLen);
    else
      while (block.palColour.colours.length < reqLen)
        block.palColour.colours = block.palColour.colours.concat([[0, 0, 0]]);

    // Add Data
    palBytes = palBytes.concat(10 + bits);
    for (var i = 0; i < reqLen; i++) 
    {
      palBytes = palBytes.concat([
        block.palColour.colours[i][0] * 255, 
        block.palColour.colours[i][1] * 255, 
        block.palColour.colours[i][2] * 255]);
    }
  }

  // Process Alpha
  if (block.palAlpha) 
  {
    var bits = (block.palAlpha.bits) ? (block.palAlpha.bits) : 0;
    var reqLen = Math.pow(2, bits);
    
    if (block.palAlpha.scale.length > reqLen)
      block.palAlpha.scale = block.palAlpha.scale.slice(0, reqLen);
    else
      while (block.palAlpha.scale.length < reqLen)
        block.palAlpha.scale = block.palAlpha.scale.concat(0);

    // Add Data
    palBytes = palBytes.concat(20 + bits);
    palBytes = palBytes.concat(block.palAlpha.scale);
  }

  // Process Shading Pallette
  if (block.palShade) 
  {
    var bits = (block.palShade.bits) ? (block.palShade.bits) : 0;
    var reqLen = Math.pow(2, bits);
    
    if (block.palShade.scale.length > reqLen)
      block.palShade.scale = block.palShade.scale.slice(0, reqLen);
    else
      while (block.palShade.scale.length < reqLen)
        block.palShade.scale = block.palShade.scale.concat(0);

    // Add Data
    palBytes = palBytes.concat(30 + bits);
    palBytes = palBytes.concat(block.palShade.method);
    palBytes = palBytes.concat([
      block.palShade.colour[0] * 255, 
      block.palShade.colour[1] * 255, 
      block.palShade.colour[2] * 255]);
    
    palBytes = palBytes.concat(block.palShade.scale);
  }

  // Process Smoothing Pallette
  if (block.palSmooth) 
  {
    var bits = (block.palSmooth.bits) ? (block.palSmooth.bits) : 0;
    palBytes = palBytes.concat(40 + bits);
  }
  
  return palBytes;
}

function BytesToPal(block, data) 
{
  block.artistID = BitsToBig(data.subarray(0, 4), 255)[0];
  block.blockID = BitsToBig(data.subarray(4, 4), 255)[0];
  block.size = data[8];
  
  block.palColour = undefined;
  block.palAlpha = undefined;
  block.palShade = undefined;
  block.palSmooth = undefined;
  
  var tmpData = data.subarray(9);
  // Process Pallettes
  while (tmpData.length > 0) 
  {
    if ((tmpData[0] >= 10) && (tmpData[0] < 20)) 
    {
      // Colour
      block.palColour = {'bits': tmpData[0] % 10,'colours': []};
      
      tmpData = tmpData.subarray(1);
      var reqLen = Math.pow(2, block.palColour.bits);
      for (var i = 0; i < reqLen; i++) {
        block.palColour.colours[i] = [tmpData[i * 3 + 0] / 255, tmpData[i * 3 + 1] / 255, tmpData[i * 3 + 2] / 255];
      }
      
      tmpData = tmpData.subarray(reqLen * 3);
    } 
    else if ((tmpData[0] >= 20) && (tmpData[0] < 30)) 
    {
      // Alpha
      block.palAlpha = {'bits': tmpData[0] % 10,'scale': []};
      
      tmpData = tmpData.subarray(1);
      var reqLen = Math.pow(2, block.palAlpha.bits);
      for (var i = 0; i < reqLen; i++) {
        block.palAlpha.scale[i] = tmpData[i];
      }
      
      tmpData = tmpData.subarray(reqLen);
    } 
    else if ((tmpData[0] >= 30) && (tmpData[0] < 40)) 
    {
      // Shade
      block.palShade = {'bits': tmpData[0] % 10,'method': 0,'colour': [0, 0, 0],'scale': []};
      block.palShade.method = tmpData[1];
      block.palShade.colour = [tmpData[2] / 255, tmpData[3] / 255, tmpData[4] / 255];
      
      tmpData = tmpData.subarray(5);
      var reqLen = Math.pow(2, block.palShade.bits);
      for (var i = 0; i < reqLen; i++) {
        block.palShade.scale[i] = tmpData[i];
      }
      
      tmpData = tmpData.subarray(reqLen);
    } 
    else if ((tmpData[0] >= 40) && (tmpData[0] < 50)) 
    {
      // Smooth
      block.palSmooth = {'bits': tmpData[0] % 10};
      
      tmpData = tmpData.subarray(1);
    } 
    else 
    {
      throw "Unknown Pal or Something gone wrong in processing";
    }
  }
}

function BytesToBlockBits(block, data) 
{
  block.blkBits = [];

  // Assume 8 bit MAX
  if (NumBitsPerBlockBit(block) > 8)
    throw "Too Many Bits for Block";

  // Copy Across Data
  for (var i = 0; i < data.length; i++) 
  {
    var tmpBit = data[i];
    var blkBit = {'empty': (tmpBit & 1)};
    
    if (tmpBit & 2) 
    {
      blkBit.link = 1;
    }
    
    var c = 2;
    
    if (block.palColour && block.palColour.bits) 
    {
      blkBit.colour = (tmpBit >> c) % Math.pow(2, block.palColour.bits)
      c += block.palColour.bits;
    }
    
    if (block.palAlpha && block.palAlpha.bits) 
    {
      blkBit.alpha = (tmpBit >> c) % Math.pow(2, block.palAlpha.bits)
      c += block.palAlpha.bits;
    }
    
    if (block.palShade && block.palShade.bits) 
    {
      blkBit.shade = (tmpBit >> c) % Math.pow(2, block.palShade.bits)
      c += block.palShade.bits;
    }
    
    if (block.palSmooth && block.palSmooth.bits) 
    {
      blkBit.smooth = (tmpBit >> c) % Math.pow(2, block.palSmooth.bits)
      c += block.palSmooth.bits;
    }
    
    block.blkBits = block.blkBits.concat(blkBit);
  }
}

function BytesToLinks(block, data) 
{
  // Generating Flat List of ID
  var flatIDList = [];
  
  for (var i = 0; i < currBlock.blkBits.length; i++)
    if (block.blkBits[i].link)
      flatIDList = flatIDList.concat(i);

  // Decode Links
  var flatLinkDataList = BitsToBig(data, 255);
  
  for (var i = 0; i < flatIDList.length; ++i)
    block.blkBits[flatIDList[i]].link = [flatLinkDataList[i * 2 + 0], flatLinkDataList[i * 2 + 1]];
}

function processMessage(e) 
{
  if (this.status == 200) 
  {
    lastResponse = this;
    
    rawResponse = this.response;
    console.log(rawResponse);
    
    var szBlock = Number(this.getResponseHeader('szBlock'));
    var szPal = Number(this.getResponseHeader('szPal'));
    var szLink = Number(this.getResponseHeader('szLink'));
    
    var blockRecvData = new Uint8Array(rawResponse, 0, szBlock);
    var palRecvData = new Uint8Array(rawResponse, szBlock, szPal);
    var linkRecvData = new Uint8Array(rawResponse, szBlock + szPal, szLink);

    // Display Data
    $('blockRaw').innerHTML = '';
    for (var i = 0; i < blockRecvData.length; i++) 
    {
      if (i > 0) 
      {
        if ((i % 8) == 0) 
        {
          $('blockRaw').innerHTML += '\n';
          $('blockDisplay').innerHTML += '<br/>';
        }
        
        if ((i % 64) == 0) 
        {
          $('blockRaw').innerHTML += '\n';
          $('blockDisplay').innerHTML += '<hr/>';
        }
      }
      
      $('blockRaw').innerHTML += aHex(blockRecvData[i], 2) + ' ';
    }
    
    $('palRaw').innerHTML = '';
    for (var i = 0; i < palRecvData.length; i++) 
    {
      if (i > 0) 
      {
        if ((i % 8) == 0)
          $('palRaw').innerHTML += '\n';
        if ((i % 64) == 0)
          $('palRaw').innerHTML += '\n';
      }
      
      $('palRaw').innerHTML += aHex(palRecvData[i], 2) + ' ';
    }

    // Convert Data
    currBlock = {};
    BytesToPal(currBlock, palRecvData);
    BytesToBlockBits(currBlock, blockRecvData);
    BytesToLinks(currBlock, linkRecvData);
    
    UpdatePalDisplay();
    UpdateCubeDisplay();
  }
}

function makBlockBit(blkBit) 
{
  var blk = document.createElement('span');
  blk.className = 'block';
  
  if (blkBit.empty) 
  {
    blk.style.setProperty('border', '1px dashed #000');
  } 
  else 
  {
    var colour = [1, 1, 1];
    
    if (blkBit.colour && currBlock.palColour && currBlock.palColour.bits) 
    {
      colour[0] = currBlock.palColour.colours[blkBit.colour][0];
      colour[1] = currBlock.palColour.colours[blkBit.colour][1];
      colour[2] = currBlock.palColour.colours[blkBit.colour][2];
    }
    
    if (blkBit.shade && currBlock.palShade && currBlock.palShade.bits) 
    {
      var tint = currBlock.palShade.colour;
      var lvl = currBlock.palShade.scale[blkBit.shade] / 100;
      
      switch (currBlock.palShade.method) 
      {
        case 0: // Multiply
          colour[0] = colour[0] + (tint[0] - 1) * lvl * colour[0];
          colour[1] = colour[1] + (tint[1] - 1) * lvl * colour[1];
          colour[2] = colour[2] + (tint[2] - 1) * lvl * colour[2];
          break;
        case 1: // Blend
          colour[0] = colour[0] + (tint[0] - colour[0]) * lvl;
          colour[1] = colour[1] + (tint[1] - colour[1]) * lvl;
          colour[2] = colour[2] + (tint[2] - colour[2]) * lvl;
          break;
      }
    }
    
    if (blkBit.alpha && currBlock.palAlpha && currBlock.palAlpha.bits) 
    {
      colour[3] = currBlock.palAlpha.scale[blkBit.alpha];
    }
    
    blk.style.setProperty('background-color', toCssCol(colour));
  }

  // Link
  if (blkBit.link) 
  {
    var linkSpan = document.createElement('span');
    linkSpan.className = 'blkHoverData';
    linkSpan.innerHTML = '<b>Artist&nbsp;#' + blkBit.link[0] + '</b> <em>Block&nbsp;#' + blkBit.link[1] + '</em>';
    
    blk.classList.add('blkLink');
    blk.appendChild(linkSpan);
  }

  // Smoothing
  if (blkBit.smooth) 
  {
    blk.classList.add('blkSmooth');
  }
  
  return blk;
}

function UpdatePalDisplay() 
{
  var palDisplay = $('palDisplay');
  palDisplay.innerHTML = '';

  // Update Pal Display
  s = '';
  s += '<span class="artistID">Artist #' + currBlock.artistID + '</span>';
  s += '<span class="blockID">Block #' + currBlock.artistID + '</span>';
  s += '<span class="bitsPerBlock">' + NumBitsPerBlockBit(currBlock) + '</span>';
  
  if (currBlock.palColour) 
  {
    s += '<div class="pal palColour">';
    s += '<h3>Colour Pallette</h3>';
    s += '<span class="bitsUsed">' + currBlock.palColour.bits + '</span>';
    for (var i = 0; i < currBlock.palColour.colours.length; i++) 
    {
      s += '<span class="blot" style="background-color:' + rgb(currBlock.palColour.colours[i]) + ';"></span>';
    }

    s += '</div>'
  }
  
  if (currBlock.palAlpha) 
  {
    s += '<div class="pal palAlpha">';
    s += '<h3>Alpha Pallette</h3>';
    s += '<span class="bitsUsed">' + currBlock.palAlpha.bits + '</span>';
    for (var i = 0; i < currBlock.palAlpha.scale.length; i++) 
    {
      s += '<span class="blot" style="background-color:' + rgba([0, 0, 0, currBlock.palAlpha.scale[i] / 100]) + ';"></span>';
    }

    s += '</div>'
  }
  
  if (currBlock.palShade) 
  {
    s += '<div class="pal palShade">';
    s += '<h3>Shading Pallette</h3>';
    s += '<span class="bitsUsed">' + currBlock.palShade.bits + '</span>';
    s += '<span class="method">' + shadingMethods[currBlock.palShade.method] + '</span>';
    for (var i = 0; i < currBlock.palShade.scale.length; i++) 
    {
      s += '<span class="blot" style="background-color:' + rgba([currBlock.palShade.colour[0], currBlock.palShade.colour[1], currBlock.palShade.colour[2], currBlock.palShade.scale[i] / 100]) + ';"></span>';
    }

    s += '</div>'
  }
  
  if (currBlock.palSmooth) 
  {
    s += '<div class="pal palSmooth">';
    s += '<h3>Smoothing Pallette</h3>';
    s += '<span class="bitsUsed">' + currBlock.palSmooth.bits + '</span>';
    s += '</div>'
  }
  
  console.log(s);
  
  palDisplay.innerHTML = s;
}

function UpdateCubeDisplay() 
{
  // Update Cube Display
  var blkDisplay = $('blockDisplay');
  
  var currLayer = document.createElement('div');
  currLayer.id = 'layer0';
  currLayer.className = 'layer';
  
  for (var i = 0; i < currBlock.blkBits.length; i++) 
  {
    if (i == 0)
      blkDisplay.innerHTML = '';
    else if ((i % 64) == 0) 
    {
      blkDisplay.appendChild(currLayer);
      
      currLayer = document.createElement('div');
      currLayer.id = 'layer' + (i / 64);
      currLayer.className = 'layer';
    } 
    else if ((i % 8) == 0)
      currLayer.innerHTML += '<br />';
    
    currLayer.appendChild(makBlockBit(currBlock.blkBits[i]));
  }

  
  blkDisplay.appendChild(currLayer);

}

function doJSSubmit() 
{
  // Assume 8bit max
  if (NumBitsPerBlockBit(currBlock) > 8)
    throw "Too Many Bits for Block";

  // Random Data
  var palBytes = PalToBytes(currBlock);
  var palSendData = new Uint8Array(palBytes.length);
  palSendData.set(palBytes);
  
  var flatLinkList = [];
  var blockSendData = new Uint8Array(currBlock.blkBits.length);
  
  for (var i = 0; i < currBlock.blkBits.length; i++) {
    blockSendData[i] = BlockBitToBytes(currBlock, currBlock.blkBits[i]);
    
    if (currBlock.blkBits[i].link) 
    {
      flatLinkList = flatLinkList.concat(currBlock.blkBits[i].link);
    }
  }
  
  flatLinkList = BigToBits(flatLinkList, 255);
  var linkSendData = new Uint8Array(flatLinkList.length)
  linkSendData.set(flatLinkList);

  // Arguments
  var args = {
    'szBlock': blockSendData.byteLength,
    'szPal': palSendData.byteLength,
    'szLink': linkSendData.byteLength
  };

  // Setup Transfer Data
  var bugger = new ArrayBuffer(blockSendData.byteLength + palSendData.byteLength + linkSendData.byteLength);
  var cpyBData = new Uint8Array(bugger, 0, blockSendData.length);
  var cpyPData = new Uint8Array(bugger, blockSendData.byteLength, palSendData.length);
  var cpyLData = new Uint8Array(bugger, blockSendData.byteLength + palSendData.byteLength, linkSendData.length);
  
  cpyBData.set(blockSendData);
  cpyPData.set(palSendData);
  cpyLData.set(linkSendData);
  
  console.log(blockSendData.byteLength + palSendData.byteLength + linkSendData.byteLength);
  console.log(blockSendData.length + palSendData.length + linkSendData.length);

  // Setup and Send
  var xhr = new XMLHttpRequest();
  xhr.open('POST', '/blockEditor' + argToParams(args), true);
  xhr.responseType = 'arraybuffer';
  xhr.setRequestHeader('Content-Type', 'application/octlet;base64')
  xhr.onload = processMessage;
  xhr.send(bugger);
}

function FlattenDict(dict) 
{
  var x = [];
  var result = [];

  // Get Sorter List of Non Empty Keys
  for (var item in blkLinks) 
  {
    if (blkLinks[item] != undefined) 
    {
      x = x.concat(Number(item));
    }
  }
  
  x = x.sort(function(a, b) {
    return a > b;
  });
  
  for (var i = 0; i < x.length; i++) 
  {
    result = result.concat(x[i]);
  }
  return result;
}

function SelectLayer(x) 
{
  var layers = document.getElementsByClassName("layer");
  
  for (var i = 0; i < layers.length; ++i)
    if (i <= x)
      layers[i].classList.remove('hidden');
    else
      layers[i].classList.add('hidden');
}

//=========================================================================================================
//=========================================================================================================
//=========================================================================================================
//=========================================================================================================
//=========================================================================================================
</script>
</head>
  <body>
    <span class="submitButton" onclick="doJSSubmit();">Submit to Server</span>

    <div id="palDisplay"></div>
    <div id="blockDisplay"></div>
    <div style="display: inline-block;" >
      <input type="range" min="0" max="7" 
          onchange="SelectLayer(this.value);" 
          style="-webkit-appearance: slider-vertical; width: 50px; height: 200px;"/>
    </div>

    <div class="debug" style="display: inline-block;">
      <span id="palRaw" class="data"></span>
      <span id="blockRaw" class="data"></span>
    </div>    

    <script type="text/javascript">

UpdatePalDisplay();
UpdateCubeDisplay();
</script>

  </body>
</html>